# 프로세스 ![Heart](https://user-images.githubusercontent.com/49769190/149621060-3c93b46e-5fea-4b46-a825-0b0a497fffd7.png)
  
  현재 활동의 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다.
  
  텍스터 및 데이터 섹션의 크기는 고정되기 때문에 실행시간 동안 크기가 변하지 않는다.
  
  <img width="243" alt="image" src="https://user-images.githubusercontent.com/49769190/149624919-cb707678-a061-4158-ad52-e3a275daa306.png">
  #### 그림 프로세스 메모리 배치
  * 텍스트 색션 - 실행코드 
  * 데이터 색션 - 전역 변수 
  * 힙 색션 - 프로그램 실행 중에 동적으로 할당되는 메모리
  
  ## 프로세스 상태
  프로세스는 실행되면서 그 상태가 변한다. 프로세스의 상태는 부분적으로 그 프로세스의 현재의 상태에 따라서 정의된다. 
  * 새로운(new): 생성 중
  * 실행(running): 명령어들이 실행
  * 대기(waiting): 프로세스가 어떤 이벤트가 일어나기를 기다림
  * 준비(ready): 프로세스가 처리기에 할당되기를 기다림
  * 종료(terminated): 프로세서의 실행이 종료됨

  <img width="803" alt="image" src="https://user-images.githubusercontent.com/49769190/149624884-2d0fa584-10f1-4f56-82c4-3302468f3db6.png">
    
  ## 프로세서 제어 블록(Process Control Block: PCB)
   테스크 제어 블록이라고 불림, 
   * 프로세서 상태: new, running, waiting or halted(정지) 상태 등
   * 프로그램 카운터: 다음 실행할 프로세서 주소를 가리킴
   * CPU 레지스터들:  컴퓨터의 구조에 따라 다양한 수와 유형을 가짐, 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터들, 상태코드 정보가 포함된다.
         프로세서 스케줄 계속 반영되도록 인터럽트 발생 시 저장되어야 함
   * CPU-스케줄링 정보: 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함
   * 메모리 관리 정보: 운영체제에 의해 사용되는 메모리 시스템에 따라 기준 레지스터와 한계 레지스터 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보 포함
   * 회계 정보: CPU 사용 시간과 경과된 시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함
   * 입출력 상태 정보: 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함
    
    
   
   <img width="500" alt="image" src="https://user-images.githubusercontent.com/49769190/149624948-32dc1e46-4f1e-4429-bcc5-b67bf63eff00.png">

   ## 스레드(Threads)
   모델은 프로세스가 단일의 실행 스레드를 실행하는 프로그램임을 암시했다.
   
   ## 프로세스 스케줄링(Process Scheduling)
   다중 프로그램의 목적은 CPU 이용을 최대화하기 위하여 항상 어떤 프로세스가 실행되도록 하는 데 있다. 사분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세서들 사이에서 CPU 코어를 빈번하게
   교체하는 것임
   코어에서 실행 가능한 여러 프로세서 중에서 하나의 프로세스를 선택함, 각 코어는 한 번에 2개 이상의 프로세서가 실행될 수 없지만 다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있음
   현재 메모리에 있는 프로세스 수를 다중 프로그래밍 정도라고 함
   I/O 바운드 프로세스는 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스임, CPU 바운드 프로세스는 계산에 더 많은 시간을 사용하여 I/O 요청을 자주 생성 하지 않음
   
   ### 스케줄링 큐(Scheduling Queue)
   프로세스는 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다림. 준비 큐 헤더에서 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가르키는 포인터 필드가 포함
   시스템에는 다른 큐도 존재, 프로세승에 CPU 코어가 할당되면 프로세스는 잠시 동안 실행되어 결국 종료 or 인터럽트 되거나 I/O 요청의 완료와 같은 이벤트 발생할 떄까지 기다림
   I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐에 삽입
   <img width="803" alt="image" src="https://user-images.githubusercontent.com/49769190/149624224-f4d08290-b49d-45ec-a666-71577c21ed8b.png">
   스케줄링의 일반적인 표현은 큐잉 다이어그램임, 준비 큐와 대기 큐의 집합의 두 가지 유형의 큐가 제시되어 있음, 
     * 원은 큐에 서비스를 제공하는 자원을 나타내고 화살표는 프로세스의 흐름 (큐잉 다이어그램)
      ![image](https://user-images.githubusercontent.com/49769190/149623182-8ee49de0-4eb0-4d84-9bb1-645b5c547422.png)
      
    새 프로세스는 처음에 준비 큐에 놓임, 프로세스는 실행을 위해 선택되거나 디스패치 될 때까지 기다림. CPU 코어가 할당되고 실행 상태가 되면 여러 이벤트 중 하나가 발생할 수 있음
    
   
   
  
 


